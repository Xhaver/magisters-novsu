# magisters-novsu
## Вопросы для подготовки к вступительным экзаменам в магистратуру НовГУ
### Инструкция по обновлению: 
    1. Делаете форк репозитория
    2. Отправляете свою ИЗМЕНЕННУЮ ветку в пул реквест основного репа
    3. Ждете апрува
    4. Аминь
    5. Заголовки под тегом '###'. Пример: '### Жизненный цикл БД'.


### 1. Задачи и этапы проектирования и создания базы данных. Жизненный цикл базы данных.

Проектирование базы данных включает в себя следующие шаги:

    а. Определение назначения
    б. Поиск и упорядочивание данных
    в. Разделение базы на сущности (т.е. отдельные таблицы)
    г. Распределение данных по строкам в таблицах.
    д. Настройка типов данных, связей между базами.

Жизненный цикл БД включает в себя 7 этапов:

    а. Предварительное планирование БД
    б. Проверка возможности существования (есть ли необходимые технологии для определения БД)
    в. Определение требований (цели, потребности, требования к обороудованию, ПО)
    г. Концептуальное проектирование (Создаются модели данных на основе пользовательских представлений,
      затем эти представлений складывают воедино 
       и получают че то вразумительное, ну или иными словами - концепцию БД)
    д. Логическое проектирование (Выбор типа модели данных, идет следом за концептуальным)
    е. Физическое проектирование (расширение модели данных с учетом всех факторов и рекомендаций для
       дальнейшего деплоя в сетку приложений)
    ж. Оценка и поддержка БД

### 3. Язык SQL. Агрегатные функции языка. Группирование результатов. Вложенные запросы.

### **3.1 - Язык SQL**

Язык SQL (Structured Query Language т.е. "язык структурированных запросов") - язык программирования, разработанный для работы с реляционными базами данных: создания, модификации и управлением данными и таблицами их хранящими. Является декларативным языком, т.е. описывает ожидаемый результат выполнения программы. В настоящее время разрабатываются SQL-запросы к Системам Управления Баз Данных (СУБД), а как обработать запрос пользователя - решает сама СУБД. 
К текущему моменту является языком мирового стандарта работы с реляционными базами данных. Имеет множетство различных видов реализации языка запросов (называемых диалектами), таких как PostgreSQL, MS SQL Server, MySQL и т.д., различающихся специфичными, для одноимённых СУБД, элементами, расширяющими базовые возможности SQL, описанные в стандарте. 
Бозовыми, для языка SQL, являются операторы:
    Определения данных (таблиц, представлений, пользователя):
        CREATE - создание объекта базы данных 
        ALTER  - изменение объекта
        DROP   - удаление объекта
    Манипулации данными (данными в таблице):
        SELECT - выбор данных, удовлетворяющим условиям
        INSERT - добалвение новых данных
        UPDATE - обновление существующих данных
        DELETE - удаление данных
    Определния доступа к данным (разграничением доступа пользователей базы данных):
        GRANT  - предоставляет доступ на выполнение действий (см. предыдущие элементы языка) пользователю/группе
        REVOKE - отзывает ранее выданный доступ
        DENY   - определяет полный запрет на выполнение действий
    Управления транзакциями (последовательностью действий, являющейся атомарной, т.е такой, что ни одна из операций не может быть выполнена, если, последовательное выполнение их не возможно):
        COMMIT    - выполняет транзакцию
        ROLLBACK  - отменяет все изменения, выполненные в рамках текущей транзакци
        SAVEPOINT - делит транзакцию на более мелкие участки
Практически каждый оператор имеет свои предложения, специфицирующие поведение оператора или объект, с которыми будет работать оператор.
Поскольку язык SQL разрабатывался с учётом возможности его использования не профессиональными программистами - его синтаксис очень сильно напоминает обычный разговорный язык. Для примера представим запрос на выбор данных:
SELECT 'какое поле выбрать?' FROM 'из какого объетка? (таблицы)';
Если нужно ограничить выбор данными с определёнными условиями и выбрать сразу же все записи из таблицы, пользователь задаёт нужные значения полей, используя привычные конструкции:
SELECT 'название_поля' FROM 'имя_таблицы' WHERE 'название_поля' > 2;
Получается достаточно легко читаемое предложение: 
ВЫБРАТЬ 'название_поля' ИЗ ТАБЛИЦЫ 'имя_таблицы' ГДЕПОЛЕУДОВЛ.УСЛОВИЮ 'название_поля' ОПЕРАТОР_УСЛОВИЯ 'значение_поля';

### **3.2 - Агрегатные функции языка**
Агрегатные функции, называемые так же "обобщающими" или итоговыми, в текущем стандарте SQL представлены 5-ью функциями:
    COUNT, SUM, AVG, MIN, MAX
Используются в предложениях "SELECT", описывая, что нужно сделать с данными в указанном поле. SQL запрос принимает вид (на примере функции MAX):
SELECT **MAX**('название_поля') FROM 'имя_таблицы' 
При этом выборка может быть уточнена оператором WHERE. Агрегатная функция будет применена только к удовлетворяющим условиям WHERE результатам. 

Возвращаясь к функциям, рассмотрим их функционал. Любая агрегатная функция, вместо выборки конкретных данных, имеющихся в таблице, запрос вернёт единственное значение. 
    Сами названия функций лаконично описывают результат их работы:
    COUNT - Возвращает количество всех строк, полученных в результате выполнения запроса. 
    SUM   - Вовзращает сумму всех значений в указанном столбце.
    AVG   - Возвращает среднее значение в указанном столбце.
Агрегатные функции SUM и AVG работают только с числовыми данными.
    MIN   - Возвращает минимальное значение в указанном столбце.
    MAX   - Возвращает минимальное значение в указанном столбце.
Агрегатные функции MAX и MIN могут обрабатывать любые столбцы, которые можно как-либо упорядочить. 

Cтоит отметить, что возращаемый результат - одна строка и один стоблец, в единственном поле которого находится результат выполнения агрегатной функци.

Подытоживая ответ на вопрос об агрегатных функциях - это вспомогательные функции, которые помогают получать конкретный результат от СУБД, не занимаясь обработкой данных, выбранных из таблицы.

### **3.2 - Группирование результатов.**
Группирование результатов в SQL выполняется с помощью оператора GROUP BY предложения SELECT. Группирование позволяет объединять результаты выборки из таблицы на основании данных в столбцах. Рассмотрим структуру запроса:
    SELECT 'литералы, агрегатные_функции, столбцы_группировки'
    FROM 'имя_таблицы'
    GROUP BY 'столбцы_группировки';
Ключевое слово GROUP BY группирует результаты по значением полей в столбце. Все поля, имеющие равные значение (в том числе NULL будут одной группой), будут выделены в группы по этим значениям этих полей.


### **3.3 - Вложенные запросы.**
Вложенный запрос - запрос, который используется внутри другого SQL запроса. Вложенные запросы могут быть использованы везде, где разрешено использовать SQL выражения. Общим, для всех вложенных запросов, является заключение тела запроса в скобки.
Конечный результат выполнения запроса такой же, как и у обычного запроса. Порядок выполнения запросов: из центра наружу. Т.е. сначала выполняется самый "глубокий" по уровню вложенности запрос, с результатами которого будет работать основной запрос.

Простейшим примером использования вложенных запросов является использоваение результатов вложенного запроса для вывода полной строки таблицы, удовлетворяющей условиям вложенного запроса:
    SELECT * FROM 'имя_таблицы' WHERE 'имя_столбца' = (SELECT MAX('имя_столбца') FROM 'имя таблицы')
В данном примере вложенный запрос "(SELECT MAX('имя_столбца') FROM 'имя таблицы')" вернёт максимальное ЗНАЧЕНИЕ среди всех полей столбца в основной запрос, где сравнение будет происходить между всеми полями столбца и максимальным значением. Для данного примера можно изменить агрегатную функцию на MIN и найти минимальное значение.
Но даже данный пример показывает возможные проблеммы с эффективностью вложенных функций, т.к., сначала выполняется вложенный запрос, анализирующий всю таблицу, после чего основной запрос делает выборку на таком же по объёму набору данных. При более сложных запросах и уровнях вложенности - уровень сложности выполнения таких функций растёт в геометрической прогрессии.

Вложенные запросы можно использовать со всеми предложениями/операторами/функциями языка SQL, если результат выполнения этого запросам - подходит под формат входных данных основного запроса. Следовательно - данные запросы могут быть использованы для выборки данных, как спецификатор условий выбора по результату вложенного запроса для секций WHERE, как запрос определяющий, каких полей достаточно для основного запроса для секций JOIN, FROM, в секции SELECT можно получать, используя псевдонимы, данные из связанных каким-либо полем таблиц.

Источники:

1. **ISO - International Organization for Standardization** - www.iso.org + ANSI
2. **American National Standards Institute - ANSI Home** - www.ansi.org
3. **MS SQL Documentation** - www.learn.microsoft.com/ru-ru/sql/sql-server/
4. **Базы данных : учеб, пособие для вузов** - Кузин А. В.
5. **Основы SQL : учеб, пособие для вузов** - Полякова Л. Н.

### 4. Управление транзакциями. Модель транзакции. Свойства транзакции. Журнализация. Проблемы многопользовательских систем. Блокировки.

#### **Транзакция**

**Транзакция** - это последовательность операций над базой данных, рассматриваемых СУБД как единое целое.

Под управлением транзакциями понимается способность управлять различными операциями над данными, которые выполняются внутри реляционной СУБД. 

Управление транзакциями необходимо для поддержания логической целостности базы данных.

Пример транзакции (SQLite):

    BEGIN TRANSACTION;

    INSERT OR ROLLBACK INTO Orders (id_product, total)
    VALUES (2, 4800);

    UPDATE OR ROLLBACK Products
        SET quantity = quantity - 6
    WHERE id_product = 2;

    INSERT OR ROLLBACK INTO Invoices (id_order, id_product, num_order, sum_order, return, date)
    VALUES (1, 2, 6, 4800, 0, DATETIME('now'));

    COMMIT TRANSACTION;

#### **Модель транзакции**

**Модель транзакции** включает в себя следующие операторы:
    
1. **Оператор COMMIT**. Если все операции успешно выполнены, то транзакция также считается успешно выполненной и СУБД фиксирует (COMMIT) все изменения данных, произведенные этой транзакцией (то есть заносит изменения во внешнюю память).

2. **Оператор ROLLBACK**. Если же хотя бы одна операция транзакции заканчивается неудачей, то транзакция считается невыполненной и производится откат (ROLLBACK) — отмена всех изменений данных, произведенных в ходе выполнения транзакции, и возврат базы данных к состоянию до начала выполнения транзакции.

3. **Оператор SAVEPOINT**. Операция точки сохранения, которая предназначена для установки в транзакции особых точек, куда в дальнейшем может быть произведен откат (при этом отката всей транзакции не происходит).

Модель транзации можно видеть на следующей схеме:

<p align="center">
    <img src="pictures/4_1.jpg" style="width: 550px">
</p>

В этой схеме можно видеть следующие варианты работы транзакции:

1. Оператор COMMIT означает успешное завершение транзакции; его использование делает постоянными изменения, внесенные в базу данных в рамках текущей транзакции;

2. Оператор ROLLBACK прерывает транзакцию, отменяя изменения, сделанные в базе данных в рамках этой транзакции; новая транзакция начинается непосредственно после использования ROLLBACK;

3. Успешное завершение программы, в которой была инициирована текущая транзакция, означает успешное завершение транзакции (как будто был использован оператор COMMIT);

4. Ошибочное завершение программы прерывает транзакцию (как будто был использован оператор ROLLBACK).


#### **Свойства транзакции**

**Свойства транзакции** описываются аббревиатурой ACID (Atomicity, Consistency, Isolation, Durability):

1. **Свойство «Атомарность» (Atomicity)**. Атомарность гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем. Не допускаются промежуточные состояния.

2. **Свойство «Согласованность» (Consistency)**. Данное свойство гласит, что транзакция, достигающая своего нормального завершения и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных (то есть каждая успешная транзакция по определению фиксирует только допустимые результаты). Данное свойство «вытекает» из свойства атомарности.

3. **Свойство «Изолированность» (Isolation)**. Данное свойство означает, что транзакции параллельные транзакции не должны оказывать влияние на ее результаты.

4. **Свойство «Устойчивость» (Durability)**. Свойство означает, что если транзакция выполнена, и даже если в следующий момент произойдет сбой в системе, результат сохранится.

#### **Журнализация**

В случае аппаратных или программных сбоев может привести к повреждению данных в БД. Для восстановления информации в базе данных необходимо иметь некоторую дополнительную информацию. Таким образом, для поддержания надежности хранения данных требуется избыточность данных. Для таких целей существует **журнализация**.

**Журнал** хранит изменения, выполненные транзакциями, обеспечивает атомарность и устойчивость данных в случае сбоя системы.

**Журнал** содержит значения, которые данные имели до и после их изменения транзакцией. *Write-ahead log strategy* обязывает добавлять в журнал запись о предыдущих значениях до начала, а о конечных после завершения транзакции. В случае внезапной остановки системы БД читает лог в обратном порядке и отменяет изменения, сделанные транзакциями. Встретив прерванную транзакцию БД выполняет ее и вносит изменения о ней в журнал. Находясь в состоянии на момент сбоя, БД читает лог в прямом порядке и возвращает изменения, сделанные транзакциями.

#### **Проблемы многопользовательских СУБД**

Естественным следствием развития СУБД является проблема организации совместной работы нескольких пользователей с одной и той же совокупностью данных, или, проблемы многопользовательского доступа к данным.

Если в многопользовательской системе не реализованы механизмы совместной работы нескольких пользователей, то в СУБД это может привести к следующим проблемам:

1. **Проблема «последнего изменения»**. Возникает, когда несколько пользователей изменяют одну и ту же строку, основываясь на ее начальном значении; тогда часть данных будет потеряна, так как каждая последующая транзакция перезапишет изменения, сделанные предыдущей. Выход из этой ситуации заключается в последовательном внесении изменений;

2. **Проблема «грязного чтения»**. Возможна в том случае, если пользователь выполняет сложные операции обработки данных, требующие множественного изменения данных перед тем, как они обретут логически верное состояние. Если во время изменения данных другой пользователь будет считывать их, то может оказаться, что он получит логически неверную информацию. Для исключения подобных проблем необходимо производить считывание данных после окончания всех изменений;

3. **Проблема «неповторяемого чтения»**. Является следствием неоднократного считывания транзакцией одних и тех же данных. Во время выполнения первой транзакции другая может внести в данные изменения, поэтому при повторном чтении первая транзакция получит уже иной набор данных, что приводит к нарушению их целостности или логической несогласованности;

4. **Проблема «чтения фантомов»**. Появляется после того, как одна транзакция выбирает данные из таблицы, а другая вставляет или удаляет строки до завершения первой. Выбранные из таблицы значения будут некорректны.

Решением проблемы параллельной обработки БД заключается в том, что строки таблиц блокируются, а последующие транзакции, модифицирующие эти строки, отвергаются и переводятся в режим ожидания. Решается это с помощью блокировок.

#### **Блокировки**

**Блокировкой** называется временное ограничение на выполнение некоторых операций обработки данных. Блокировка может быть наложена как на отдельную строку таблицы, отдельную таблицу, так и на всю базу данных.

Управлением блокировками на сервере СУБД занимается менеджер блокировок, контролирующий их применение и разрешение конфликтов.

Транзакции и блокировки тесно связаны друг с другом. Транзакции накладывают блокировки на данные, чтобы обеспечить выполнение требований ACID. Без использования блокировок несколько транзакций могли бы изменять одни и те же данные.

Различают следующие типы блокировок:

1. По степени доступности данных: разделяемые и исключающие;
2. По множеству блокируемых данных: строчные, страничные, табличные;
3. По способу установки: автоматические (не явные) и явные;
4. По логике реализации: пессиместическая и оптимистическая.

Пример блокировки (MS SQL):

    LOCK TABLES users WRITE;
    INSERT INTO users (name) VALUES (‘Вася’);
    UNLOCK TABLES;

Работа с транзакциями есть и в моем проекте «Автоматизация извлечения информации о клиентах для базы 1С с применением машинного обучения». В моем случае, транзакция применяется когда пользователь захочет записать данные по всем найденным клиентам в БД. В этом случае, все временно созданные объекты пытаются записаться в транзакции. Если какой-то из объектов не удалось записать, тогда вся транзакция отменяется.

    НачатьТранзакцию();

    Попытка
        Для Каждого ТекущийОбработанныйОбъект Из ОбъектыОбработки Цикл
            ТекущийОбработанныйОбъект.ОбменДанным.Загрузка = Истина;
            ТекущийОбработанныйОбъект.Записать();
        КонецЦикла;

        ЗафиксироватьТранзакцию();
    Исключение
        ОтменитьТранзакцию();
    КонецПопытки;

Также в работе применяются и блокировки. Выполнить блокировку в 1С можно с помощью специального объекта встроенного языка 1С. Сделано это следующим образом:

	БлокировкаДанных = Новый БлокировкаДанных;
	
	ЭлементБлокировки = БлокировкаДанных.Добавить("Документ.ML_ФреймОбработкиДанных");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	ЭлементБлокировки.УстановитьЗначение("МодельМашинногоОбучения", ТекущаяМодельМашинногоОбучения);

	БлокировкаДанных.Заблокировать();

Блокировка в моей работе необходима для того, чтобы никто из пользоватей не мог редактировать дата сет по нужной модели машинного обучения, пока данная модель обучается или производится оценка ее точности.

Источники:

1. **Web SQL Database** - www.w3.org
2. **SQLite Documentation** - www.sqlite.org/docs.html
3. **MS SQL Documentation** - www.learn.microsoft.com/ru-ru/sql/sql-server/
4. **Базы данных : учеб, пособие для вузов** - Кузин А. В.
5. **Основы SQL : учеб, пособие для вузов** - Полякова Л. Н.

### 9. Архитектура многопользовательских СУБД. Модель сервера баз данных. Сервер приложений. Трехуровневая модель.

#### **Архитектура многопользовательских СУБД.**

**Система управления базами данных (СУБД)** — совокупность
языковых и программных средств, предназначенных для создания, ведения
и совместного использования БД многими пользователями.

В зависимости от разделения функций между клиентом и сервером выделяются несколько типов архитектур систем БД, среди них:

#### **Модель сервера баз данных.**

Основу данной модели составляют следующие механизмы:
1. Механизм хранимых процедур - как средство программирования SQL-сервера;
2. Механизм триггеров - как механизм отслеживания текущего состояния информационного хранилища
3. Механизм ограничений на пользовательские типы данных, который иногда называется механизмом поддержки доменной структуры.

В этой модели бизнес-логика разделена между клиентом и сервером.
- На сервере бизнес-логика реализована в виде хранимых процедур — специальных программных модулей, которые хранятся в БД и управляются непосредственно СУБД.
- Клиентское приложение обращается к серверу с командой запуска хранимой процедуры, а сервер выполняет эту процедуру и регистрирует все изменения в БД, которые в ней предусмотрены. По итогу, сервер возвращает клиенту данные, релевантные его запросу, которые требуются клиенту либо для вывода на экран, либо для выполнения части бизнес-логики, которая расположена на клиенте.
    
Централизованный контроль в модели сервера баз данных выполняется с использованием механизма триггеров. Триггеры также являются частью БД. Механизм использования триггеров предполагает, что при срабатывании одного триггера могут возникнуть события, которые вызовут срабатывание других триггеров. Этот мощный инструмент требует тонкого и согласованного применения, чтобы не получился бесконечный цикл срабатывания триггеров.

В данной модели сервер является активным, потому что не только клиент, но и сам сервер, используя механизм триггеров, может быть инициатором обработки данных в БД. И хранимые процедуры, и триггеры хранятся в словаре БД, они могут быть использованы несколькими клиентами, что существенно уменьшает дублирование алгоритмов обработки данных в разных клиентских приложениях. Данную модель поддерживают большинство современных СУБД.

Модель сервера баз данных можно видеть на следующей схеме:

<p align="center">
    <img src="pictures/9_1.jpg">
</p>

#### **Сервер приложений. Трехуровневая модель.**

Эта модель является расширением двухуровневой модели. Данная архитектура предполагает наличие дополнительного сервера приложений, который проводит предварительную обработку запросов клиентов, формирует запросы к серверу БД и обрабатывает полученные результаты перед отправкой их клиенту.

В этой модели компоненты приложения делятся между тремя исполнителями:

1. Клиент обеспечивает логику представления, включая графический пользовательский интерфейс, локальные редакторы; клиент может запускать локальный код приложения клиента, который может содержать обращения к локальной БД, расположенной на компьютере-клиенте. Клиент исполняет коммуникационные функции front-end части приложения, которые обеспечивают доступ клиенту в локальную или глобальную сеть. Дополнительно реализация взаимодействия между клиентом и сервером может включать в себя управление распределенными транзакциями, что соответствует тем случаям, когда клиент также является клиентом менеджера распределенных транзакций.

2. Серверы приложений составляют новый промежуточный уровень архитектуры. Они спроектированы как исполнения общих незагружаемых функций для клиентов. Серверы приложений поддерживают функции клиентов как частей взаимодействующих рабочих групп, поддерживают сетевую доменную операционную среду, хранят и исполняют наиболее общие правила бизнес-логики, поддерживают каталоги с данными, обеспечивают обмен сообщениями и поддержку запросов, особенно в распределенных транзакциях.

3. Серверы баз данных в этой модели занимаются исключительно функциями СУБД: обеспечивают функции создания и ведения БД, поддерживают целостность реляционной БД, обеспечивают функции хранилищ данных (warehouse services). Кроме того, на них возлагаются функции создания резервных копий БД и восстановления БД после сбоев, управления выполнением транзакций и поддержки устаревших (унаследованных) приложений (legacy application).

Преимущества трехуровневой модели наиболее заметны в тех случаях, когда клиенты выполняют сложные аналитические расчеты над базой данных. 

Трехуровнивую модель можно видеть на следующей схеме:

<p align="center">
    <img src="pictures/9_2.jpg">
</p>

Трехуровневая модель применяется и в моем проекте «Автоматизация извлечения информации о клиентах для базы 1С с применением машинного обучения». Применяется она следующим образом: вся бизнес-логика реализована на сервере 1С, который может выполнять различные запросы на добавления, чтения, изменения или удаления данных на сервер БД. Результаты работы с БД сервер 1С отправляет пользователям, которые используют тонкий клиент 1С. Результаты работы отображаются в виде изменных форм приложения или различных сообщений, отчетов и прочего.

Схему работы можно видеть ниже:

<p align="center">
    <img src="pictures/9_3.jpg">
</p>

1. **Web SQL Database** - www.w3.org
2. **SQLite Documentation** - www.sqlite.org/docs.html
3. **MS SQL Documentation** - www.learn.microsoft.com/ru-ru/sql/sql-server/
4. **Базы данных : учеб, пособие для вузов** - Кузин А. В.
5. **Основы SQL : учеб, пособие для вузов** - Полякова Л. Н.

### 10. Архитектура многопользовательских СУБД. Модели двухуровневой технологии "клиент-сервер". Файловый сервер. Модель удалённого доступа к данным.

**Система управления базами данных (СУБД)** — совокупность
языковых и программных средств, предназначенных для создания, ведения
и совместного использования БД многими пользователями.

В зависимости от разделения функций между клиентом и сервером выделяются несколько типов архитектур систем БД, среди них:

### **10.1 - Модели двухуровневой технологии "клиент-сервер".**

Вычислительная модель клиент-сервер исходно связана с парадигмой открытых систем, которая появилась в 90-х годах и быстро развивалась. Термин клиент-сервер исходно применялся к архитектуре, при которой клиентский процесс запрашивает некоторые услуги, а серверный процесс обеспечивает их выполнение.

Реализация архитектуры клиент - сервер, применительно к разработке БД   позволяет более полно использовать ресурсы сети. Нагрузка равномерно распределяется между компьютером сервером и компьютером клиентом, который также как и сервер обладает собственными ресурсами.

Основной принцип технологии клиент – сервер, применительно к технологии БД, заключается в разделении функций стандартного интерактивного приложения на 4 группы, имеющих различную природу:
    Презентационная логика  - Функции ввода и отображения данных.
    Бизнес логика           - Прикладные функции, определяющие основные алгоритмы решения задач приложения.
    Логика обработки данных - Функции обработки данных внутри приложения .
    Служебные функции, играющие роль связок между функциями первых 3-х групп.

Следовательно, модели технологии можно выделить опираясь на то, какой функционал возьмёт на себя клиент и сервер. Если разбить группы вышеуказанных функций на более мелкие подзадачи, то классифицировать модели разделения можно будет практически бесконечно.
В общем виде выделяют лишь две модели: тонкий и толстый клиенты, которые различаются объёмом функционала, который берёт на себя клиент. Можно выделить ещё 2 группы - данные на клиенте и данные на сервере, т.к. сервер может быть в роли обработчика данных, а каждый отдельный клиент иметь свои базы данных, храние которых на сервере просто не требуется.

### **10.1 - Файловый сервер. **

Модель файлового сервера, в рамках СУБД, представляет собой клиент-серверную модель, где серверная машина выполняет функции файлового хранилища под управлением СУБД. На клиенте же распологается интерфейс доступа, логика обработки данных и их изменения.
На файл-сервер в этой модели возлагается функция только физического хранения данных. Он предоставляет рабочим станциям услуги по работе с файлами самого низкого уровня (открытие, закрытие, модификацию файлов, передачу их в канал сети и прием их из сети).
На сеть в данном случае возлагается большая нагрузка по передаче данных, т.к. файлы передаются в полном объеме от файл-сервера к клиенту и обратно.
Таким образом, при использовании файл-серверной модели, манипулированием данных занимаются несколько независимых и несогласованных между собой программ, работающих на различных рабочих станциях. Большую проблему в такой структуре представляет обеспечение целостности базы данных, когда пользователи со своих рабочих станций пытаются в одно и то же время внести в нее противоречивые изменения. Следует отметить, что для выполнения любой обработки данных (поиск, модификация, выполнение логических и математических процедур и т.д.) данные по всем открытым файлам необходимо передать по сети от сервера до рабочих станций и обратно после обработки и закрытия файлов.


### **10.1 - Модель удалённого доступа к данным.**

В этой модели презентационная логика и бизнес-логика располагаются на клиенте. На сервере располагается база данных и ядро СУБД.

Эти системы неудобны с точки зрения модификации и сопровождения. Даже при незначительном изменении функций системы требуется переделка всей прикладной части. Так как на клиенте расположена и презентационная логика и бизнес-логика приложения, то при повторении аналогичных функций  в разных приложениях код соответствующей бизнес-логики должен быть повторен для каждого клиентского приложения. В этой модели по сети передаются SQL-запросы, в ответ на запросы клиент получает  не блоки файлов, а только данные, релевантные запросу.

Сервер в этой модели играет пассивную роль, поэтому функции информационного управления должны выполняться на клиенте. Например, если необходимо выполнять контроль страховых запасов на складе, то каждое приложение, которое связано с изменением состояния склада, после выполнения операций модификации данных, имитирующих продажу или удаления товара со склада, должно выполнять проверку на объем остатка.  В случае если он меньше страхового запаса, необходимо формировать соответствующую заявку на поставку требуемого товара. Это может вызвать необоснованный заказ дополнительных товаров несколькими приложениями.

Достоинство модели – наличие большого числа готовых СУБД, имеющих SQL - интерфейсы и набор инструментальных средств, обеспечивающих создание клиентских приложений.  Основное достоинство – унификация интерфейса клиент-сервер, стандартом при общении клиента и сервера становится язык SQL.  
Недостатки: достаточно высокая загрузка системы передачи данных, вследствие того, что вся логика сосредоточена в приложении, а обрабатываемые данные расположены на удаленном узле. 

1. **ISO - International Organization for Standardization** - www.iso.org
2. **American National Standards Institute - ANSI Home** - www.ansi.org
3. **MS SQL Documentation** - www.learn.microsoft.com/ru-ru/sql/
4. **Базы данных : учеб, пособие для вузов** - Кузин А. В.
5. **Основы SQL : учеб, пособие для вузов** - Полякова Л. Н.

### 11. Основные алгоритмические структуры. Операторы условного и безусловного перехода. Циклические структуры, включая цикл foreach.

#### ***Основные алгоритмические структуры.***

**Алгоритмическая структура** - это структура, где каждая часть предназначена для выполнения определенного алгоритма преобразования информации 

Логическая структура любого алгоритма может быть представлена комбинацией трех базовых структур: *следование*, *ветвление*, *цикл*.

Самая простая из них - это **следование**. **Следование** — это часть алгоритма, в которой все команды исполняются одна за другой в порядке их записи. Алгоритм, в котором есть структура «следование» называется линейным. действие_1 действие_2 ... действие_n.

Схема:

<p align="center">
    <img src="pictures/11_1.svg" style="background: white; width: 150px">
</p>

Пример (Си):

    int a = 5;
    int b = 10;
    int c = a + b;

#### ***Операторы условного и безусловного перехода.***

Следующая группа алгоритмических структур - операторы условного и безусловного перехода.

**Ветвление** – это выбор действия в зависимости от выполнения какого-нибудь условия. Алгоритм, в котором есть структура «ветвление» называется разветвляющимся. 

Структура ветвление существует в четырех основных вариантах:

1. **если–то**; в этом случае выполнится действие (или группа действий), расположенное в строке то только при соблюдении условия. Если же условие не соблюдается, то исполнитель перейдет к выполнению действий, следующих за служебным словом все.

    Схема:

    <p align="center">
        <img src="pictures/11_2.svg" style="background: white; width: 150px">
    </p>

    Пример (Си):

        if (a > b) {
            return a;
        }

2. **если–то-иначе**; здесь представлена полная форма ветвления. В полной форме в зависимости от условия в строке если выполняется только одно из действий ( или группа действий), расположенных либо в строке то (условие соблюдено), либо в строке иначе (условие не соблюдено).

    Схема (Общая):

    <p align="center">
        <img src="pictures/11_3.svg" style="background: white; width: 400px">
    </p>

    Пример (Си):

        if (a > b) {
            return a;
        } else {
            return b;
        }

    Или пример с множественным ветвлением (Си):

        if (a > b) {
            return a;
        } else if (b > a) {
            return b;
        } else {
            return c;
        }

3. **Оператор множественного выбора**; Данный оператор сопоставляет значение заданного выражения с заранее предусмотренными вариантами. В большинстве языках реализован через оператор switch. Любую конструкцию выбора можно переписать в стандартное ветвление.

    Схема:

    <p align="center">
        <img src="pictures/11_4.svg" style="background: white; width: 500px">
    </p>

    Пример (Си):

        switch (keyCode) {
            case 1:
                // Действия для значения 1.
                break;
            case 2:
                // Действия для значения 2.
                // Обратите внимание, что нет оператора break;
                // Поэтому при выполнения case 2 выполнится case 3.
            case 3:
                // Действия для значения 3.
                break;
            default:
                // Действия, если не сопоставилось не один case.
                break;
        }

**Оператор безусловного перехода**. Оператор безусловного перехода goto означает «перейти к» и применяется в случаях, когда после выполнения некоторого оператора надо выполнить не следующий по порядку, а какой-либо другой, отмеченный меткой, оператор. Все языки программирования имели в свое время, а некоторые и до сих пор предлагают оператор goto, чье имя образовано слиянием двух английских слов "go to" (перейти к).

Применение оператора безусловного перехода считается «плохим тоном», по причине того, что данный оператор может привести к созданию нечитаемого «спагетти-кода» (очень запутанного кода).

Пример (Си):

    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++) {
            if (i == 3) {
                goto exit_jump;
            }
        }
        printf("%i\n", i);
    }

    exit_jump: printf("exit");

#### ***Циклические структуры, включая цикл foreach.***

И наконец, циклическая группа.

**Цикл** – это неоднократное повторение каких–либо действий. Алгоритм, в котором есть структура «цикл» называется циклическим. Обеспечивает многократное выполнение некоторой совокупности действий, которая называется телом цикла.

Основные разновидности циклов:

1. Цикл с предусловием; Цикл, который выполняется, пока истинно некоторое условие, указанное перед его началом. Это условие проверяется до выполнения тела цикла, поэтому тело может быть не выполнено ни разу (если условие с самого начала ложно). В большинстве процедурных языков программирования реализуется оператором while, отсюда его второе название — while-цикл.

    Схема:

    <p align="center">
        <img src="pictures/11_5.svg" style="background: white; width: 150px">
    </p>

    Пример (Си):

        int a = 0;

        while (a++ < 5) {
            printf("%i\n", a);
        }

2. Цикл с постусловием; Цикл, в котором условие проверяется после выполнения тела цикла. Отсюда следует, что тело всегда выполняется хотя бы один раз.

    Схема:

    <p align="center">
        <img src="pictures/11_6.svg" style="background: white; width: 150px">
    </p>

    Пример (Си):

        int a = 1;

        do {
            printf("%i\n", a);
        } while (a++ < 5);

3. Цикл со счетчиком; Цикл, в котором некоторая переменная изменяет своё значение от заданного начального значения до конечного значения с некоторым шагом, и для каждого значения этой переменной тело цикла выполняется один раз. В большинстве процедурных языков программирования реализуется оператором for, в котором указывается счётчик (так называемая «переменная цикла»), требуемое количество проходов (или граничное значение счётчика) и, возможно, шаг, с которым изменяется счётчик.

    Схема:

    <p align="center">
        <img src="pictures/11_7.svg" style="background: white; width: 250px">
    </p>

    Пример (Си):

        for (int i = 1; i <= 5; i++) {
            printf("%i", i);
        }

4. Цикл foreach; Цикл, задающий выполнение некоторой операции для объектов из заданного множества, без явного указания порядка перечисления этих объектов. Такие циклы называются совместными (а также циклами по коллекции, циклами просмотра) и представляют собой формальную запись инструкции вида: «Выполнить операцию X для всех элементов, входящих во множество M».

    Пример (Python):

        lst = [1, 2, 3, 4, 5]

        for lst_elem in lst:
            print(lst_elem)

Все приведенные алгоритмические структуры и используются в моем проекте «Автоматизация извлечения информации о клиентах для базы 1С с применением машинного обучения».

Пример ветвления из проекта (Встроенный язык 1С):

	Если ЭтоДокумент Тогда
		СтандартныеРеквизитыЗаполнены	= ЗначениеЗаполнено(ОбрабатываемыйОбъект.Дата);
		СтандартныйРеквизитОтказаЗаписи	= "Дата";
	Иначе
		СтандартныеРеквизитыЗаполнены	= ЗначениеЗаполнено(ОбрабатываемыйОбъект.Наименование);
		СтандартныйРеквизитОтказаЗаписи	= "Наименование";
	КонецЕсли;

Источники:

1. **WebAssembly Core Specification** - www.w3.org
2. **The GNU C Reference Manual** - www.gnu.org/software/gnu-c-manual
3. **Информатика и программирование. Основы информатики** - Н. И. Парфилова.
4. **Алгоритмы и структуры данных** - Гагарина Л. Г.

### 18. UMLдиаграммы: классов, вариантов использования, деятельности, последовательностей, состояний.

UML – унифицированный язык моделирования. UML - это система обозначений, которую можно применять для объектно-ориентированного анализа и проектирования.
Его можно использовать для визуализации, спецификации, конструирования и документирования программных систем.

    а. Диаграмма классов - структурная диаграмма языка моделирования UML, демонстрирующая общую структуру иерархии классов системы
    б. Диаграммы вариантов использования описывают взаимоотношения и зависимости между группами вариантов использования
       и действующих лиц, участвующими в процессе.
    в. Диаграмма деятельности позволяет более детально визуализировать конкретный случай использования. Это поведенческая диаграмма,
       которая иллюстрирует поток деятельности через систему. Диаграммы активности UML также могут быть использованы
       для отображения потока событий в бизнес-процессе.
    г. Диаграммы последовательности - диаграмма, на которой для некоторого набора объектов на единой временной оси показан
        жизненный цикл объекта (создание-деятельность-уничтожение некой сущности) и взаимодействие акторов 
        (действующих лиц) информационной системы в рамках прецедента.
    д. Диаграмма состояний описывает процесс изменения состояний только одного класса, а точнее – одного экземпляра
       определенного класса, т. е. моделирует все возможные изменения в состоянии конкретного объекта.

### 19. Рекурсивные функции и данные. Пример рекурсивного алгоритма. Достоинства рекурсии и недостатки.

Рекурсия — это поведение функции, при котором она вызывает сама себя. Такие функции называются рекурсивными.
В отличие от цикла, они не просто повторяются несколько раз, а работают «внутри» друг друга.

Недостатки.

      а. Скорость работы рекурсивного кода. Некоторые компиляторы могут преобразовывать хвостовую
         рекурсию в цикл, но, в целом, итеративные реализации работают быстрее практически во
         всех случаях, когда использование циклов НЕ усложняет алгоритм.
      б. требования к размеру стека, но это решается настройками компиляции или выбором языка,
         который не ограничивает размер стека

Достоинства.

      а. Эффективность применения. Некоторые алгоритмы выглядят проще и понятнее с использованием рекурсии.
      б. Рекурсии легче реализовывать, чем итерации.

Пример:

      Вычисление факториала:

      def factorial(x):
          if (x == 0):
              return 1
          return x * factorial(x - 1)

      factorial(5)

    
### 20. Обработки исключительных ситуаций. 

Исключение - тип событий при выполнении программы, который приводит к неожиданному или неправильному поведению программы. 
В рамках разработки прикладных программ, исключения можно разделить на два типа:
    1. Аппаратные (структурные, SE-Structured Exception):
    которые генерируются процессором. К ним относятся, например:
            деление на 0;
            выход за границы массива;
            обращение к невыделенной памяти;
            переполнение разрядной сетки.
    2. Программные:
    генерируемые операционной системой и прикладными программами – возникают тогда, когда программа их явно инициирует. Когда встречается аномальная ситуация, та часть программы, которая ее обнаружила, может сгенерировать, или возбудить, исключение.

Основная концепция идея обработки исключительных ситуаций состоит в том, что функция, обнаружившая проблему, но не знающая как её решить, генерирует исключение в надежде, что вызвавшая её (непосредственно или косвенно) функция сможет решить возникшую проблему. Функция, которая может решать проблемы данного типа, указывает, что она перехватывает такие исключения.

Существует два принципиально разных механизма функционирования обработчиков исключений.:
    1. Обработка с возвратом - поздразумевающая, что функция-обработчик решит проблему, вызвавшую исключение, и программа продолжит работать по основному алгоритму. При этом "проблемой" может являться поступление новых данных, требующий обработки или прерывание, вызванное таймером.
    2. Обработка без возврата - заключается в том, что после выполнения кода обработчика исключения управление передаётся в некоторое, заранее заданное место программы, и с него продолжается исполнение. То есть, фактически, при возникновении исключения команда, во время работы которой оно возникло, заменяется на безусловный переход к заданному оператору.

Сами же исключения могут быть обработаны по двум принципам:
    1. Неструктурная обработка исключений -  реализуется в виде механизма регистрации функций или команд-обработчиков для каждого возможного типа исключения. Язык программирования или его системные библиотеки предоставляют программисту как минимум две стандартные процедуры: регистрации обработчика и разрегистрации обработчика. Вызов первой из них «привязывает» обработчик к определённому исключению, вызов второй — отменяет эту «привязку». Если исключение происходит, выполнение основного кода программы немедленно прерывается и начинается выполнение обработчика. По завершении обработчика управление передаётся либо в некоторую наперёд заданную точку программы, либо обратно в точку возникновения исключения (в зависимости от заданного способа обработки — с возвратом или без).

    2. Структурная обработка исключений - требует обязательной поддержки со стороны языка программирования — наличия специальных синтаксических конструкций. Такая конструкция содержит блок контролируемого кода и обработчик (обработчики) исключений. 

Рассмотрим подробнее механизм структурной обработки исключений. Он позволяет однотипно обрабатывать как программные, так и аппаратные исключения.

В многих языках программирования структурная обработка исключений реализована блоком try{...} catch(error) {...}:
     **try {защищаемый_код}** - который отслеживает выполнение кода внутри себя и при возникновении исключительной ситуации может обработать ошибку в обработчике исключений, объявляемым сразу после защищаемого кода блоком **catch (тип_исключения усл_имя) {код_обработчика}**.
    В зависимости от реализации структурной обработки в конкретном языке программирования, обработчик может быть один на абстрактный тип ошибки или множество обработчиков для каждого типа.
    
    Исключения могут быть сгенерированы программой при помощи команды **throw**, что может быть использовано в тех ситуациях, когда сам процесс выполнения ошибочного кода (или возникновения ошибочного поведения) не вызовет системного исключения. Например, программа, выполнив запрос к внешнему источнику, ожидает поступления данных от внешнего источника, но они отстуствуют и выполнение программы не может быть продолженно. Программист может запустить таймер, который, по истечении срока ожидания сгенерирует исключение, которое позволит программе продолжить выполнения, игнорируя последующие инструкции обработки данных, а пользователь получит ошибку и сможет продолжить работать с программой.

    На языке С++ обработка исключений может быть представлена как: 
    try {
        //Код, который может вызвать исключение
        throw 15; // команда, вызывающая исключение типа int со значением 15.
    } catch (int a) { //Начало блока обработчика, который может обработать исколючение типа int
        //Код обработчика
    }
    catch (...) {// Троеточие в блоке Catch - указывает, что обработчик обрабатывает все ошибки
        //Код обработчика
    }

Обработчики - удобный 

1. **IBM** - www.ibm.com 
2. **Документация по C/C++**learn.microsoft.com/ru-ru/cpp/