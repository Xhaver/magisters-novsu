![image](https://github.com/IlyaSukharev01/magisters-novsu/assets/60602324/0f4bf4a5-0b70-4402-a80b-09f6b1e5204a)# magisters-novsu
## Вопросы для подготовки к вступительным экзаменам в магистратуру НовГУ
### Инструкция по обновлению: 
    1. Делаете форк репозитория
    2. Отправляете свою ИЗМЕНЕННУЮ ветку в пул реквест основного репа
    3. Ждете апрува
    4. Аминь
    5. Заголовки под тегом '###'. Пример: '### Жизненный цикл БД'.


### 1. Задачи и этапы проектирования и создания базы данных. Жизненный цикл базы данных.

Проектирование базы данных - это поиск способов удовлетворения функциональных требований средствами 
имеющейся компьютерной технологии с учетом заданных ограничений.

Процесс проектирования базы данных охватывает несколько основных сфер:

	1. Проектирование объектов базы данных (таблицы, представления, индексы, триггеры, хранимые процедуры, функции, пакеты)
 	   для представления данных предметной области в базе данных;
	2. Проектирование интерфейса взаимодействия с базой данных (формы, отчеты и т.д.), т.е. проектирование приложений,
 	   которые будут сопровождать данные в базе данных и реализовывать вопросно-ответные отношения на этих данных;
 	3. Проектирование баз данных под конкретную вычислительную среду или информационную технологию 
  	   (архитектура "клиент-сервер", параллельные архитектуры, распределенная вычислительная среда);
	4. проектирование баз данных под назначение системы (интеллектуальный анализ данных, OLAP, OLTP и т.д.).

Основные этапы проектирования баз данных

1.Концептуальное (инфологическое) проектирование

	Концептуальное (инфологическое) проектирование — построение семантической (смысловой) модели предметной 
  	области, то есть информационной модели наиболее высокого уровня абстракции. Такая модель создаётся без
   	ориентации на какую-либо конкретную СУБД и модель данных. Термины «семантическая модель»,
    	«концептуальная модель» и «инфологическая модель» являются синонимами. Инфологическая модель является как образом
     	реальности, так и образом проектируемой базы данных для этой реальности.

	Чаще всего концептуальная модель базы данных включает в себя:
    		1. Описание информационных объектов, или понятий предметной области и связей между ними.
    		2. Описание ограничений целостности, т.е. требований к допустимым значениям данных и к связям между ними.

2.Логическое (даталогическое) проектирование

	Логическое (даталогическое) проектирование — создание схемы базы данных на основе конкретной модели данных,
	например, реляционной модели данных. Для реляционной модели данных даталогическая модель — набор схем
	отношений, обычно с указанием первичных ключей, а также «связей» между отношениями, представляющих собой внешние ключи.

3.Физическое проектирование

	Физическое проектирование — создание схемы базы данных для конкретной СУБД. Специфика конкретной СУБД может
 	включать в себя ограничения на именование объектов базы данных, ограничения на поддерживаемые типы данных и т.п.
  	Кроме того, специфика конкретной СУБД при физическом проектировании включает выбор решений, связанных с
   	физической средой хранения данных (выбор методов управления дисковой памятью, разделение БД по файлам и устройствам, 
    	методов доступа к данным), создание индексов и т.д.
    
Модели «сущность-связь»

	Для представления конкретного вида и содержания инфологической модели предметной области, как уже говорилось, в основном используется модель
 	«сущность-связь» (англ. “Entity-Relationship model”), 	или ER-модель, предложенная П. Ченом[1] в 1976 г.
  	ER-модель обычно представляется в графической форме. Основные преимущества ER-моделей:

    		1. Наглядность;
		2. Модели позволяют проектировать базы данных с большим количеством объектов и атрибутов;
  		3. ER-модели реализованы во многих системах автоматизированного проектирования баз данных (например, ERWin).

Основные элементы ER-моделей:

    		1. Объект (сущность)- любой различимый объект (объект, который мы можем отличить от другого),
      		информацию о котором необходимо хранить в базе данных. Сущностями могут быть люди, места, самолеты, рейсы, вкус,
		цвет и т.д.;

    		2. Атрибут объекта - поименованная характеристика сущности. Его наименование должно быть уникальным 
      		для конкретного типа сущности, но может быть одинаковым для различного типа сущностей 		
		(например, ЦВЕТ может быть определен для многих сущностей: СОБАКА, АВТОМОБИЛЬ, ДЫМ и т.д.). 
  		Атрибуты используются для определения того, какая информация должна быть собрана о сущности.
    		Примерами атрибутов для сущности АВТОМОБИЛЬ являются ТИП, МАРКА, НОМЕРНОЙ ЗНАК, ЦВЕТ и т.д.

    		3. Ключ – минимальный набор атрибутов, по значениям которых можно однозначно найти требуемый экземпляр сущности.
      		Минимальность означает, что исключение из набора любого атрибута не позволяет идентифицировать сущность
		по оставшимся. Для сущности Расписание движения самолетов ключом является атрибут Номер_рейса или набор: 
  		Пункт_отправления, Время_вылета и Пункт_назначения (при условии, что из пункта в пункт вылетает в каждый момент времени один самолет).

    		4. Связь – ассоциирование двух или более сущностей. Если бы назначением базы данных было только хранение отдельных,
      		не связанных между собой данных, то ее структура могла бы быть очень простой. Однако одно из основных
		требований к организации базы данных – это обеспечение возможности отыскания одних сущностей по значениям других,
  		для чего необходимо установить между ними определенные связи. А так как в реальных базах данных нередко содержатся
    		сотни или даже тысячи сущностей, то теоретически между ними может быть установлено более миллиона связей.
      		Наличие такого множества связей и определяет сложность инфологических моделей.

Связь между сущностями характеризуется:

    1. Типом связи (1:1, 1:N, N:М);
    2. Классом принадлежности. Класс может быть обязательным и необязательным. Если каждый экземпляр
    сущности участвует в связи, то класс принадлежности — обязательный, иначе — необязательный.


Жизненный цикл БД включает в себя 7 этапов:

    а. Предварительное планирование БД
    б. Проверка возможности существования (есть ли необходимые технологии для определения БД)
    в. Определение требований (цели, потребности, требования к обороудованию, ПО)
    г. Концептуальное проектирование (Создаются модели данных на основе пользовательских представлений,
      затем эти представлений складывают воедино 
       и получают че то вразумительное, ну или иными словами - концепцию БД)
    д. Логическое проектирование (Выбор типа модели данных, идет следом за концептуальным)
    е. Физическое проектирование (расширение модели данных с учетом всех факторов и рекомендаций для
       дальнейшего деплоя в сетку приложений)
    ж. Оценка и поддержка БД

	Предварительное планирование конкретной системы управления базами данных осуществляется в процессе разработки стратегического
     	плана. Ищутся ответы на следующие вопросы:
      
    		а. Сколько используется прикладных программ и какие функции они выполняют?
    		б. Какие файлы связаны с каждым из этих приложений?
		в. Какие новые приложения и файлы находятся в процессе создания?

	Проверка осуществимости включает подготовку отчетов по следующим вопросам:

   		а. Технологическая осуществимость. Есть ли технология, необходимая для реализации запланированной базы данных?
    		б. Операционная осуществимость. Располагает ли компания персоналом, средствами и экспертами,
      		   необходимыми для успешного осуществления плана создания базы данных?
    		в. Экономическая целесообразность. Можно ли определить выгоды? Окупается ли запланированная система? Можно ли измерить издержки и выгоду?

	Определение требований включает выбор целей базы данных, выяснение информационных потребностей различных отделов\
 	и руководителей компании и требований к оборудованию и программному обеспечению.

	Этап концептуального проектирования включает создание концептуальной схемы базы данных. Спецификации
 	разрабатываются в той степени, которая требуется для перехода к реализации. На этом этапе создаются подробные модели
  	пользовательских представлений данных; затем они интегрируются в концептуальную модель, фиксирующую все элементы
   	корпоративных данных, которые будет содержать база данных.

	В процессе реализации базы данных выбирается и приобретается СУБД, затем подробная концептуальная модель превращается
 	в проект реализации базы данных; создается словарь данных, база данных наполняется данными, создаются
  	прикладные программы и обучается пользователь.

	Оценка включает опрос пользователей с целью выяснения, какие информационные потребности остались неучтенными.
 	В случае необходимости вносятся изменения. Обеспечивается поддержка системы путем внесения изменений и добавления новых программ и элементов данных по мере расширения и изменения потребностей 	бизнеса. 

Источники:
  
1. **Web SQL Database** - www.w3.org
2. **SQLite Documentation** - www.sqlite.org/docs.html
3. **MS SQL Documentation** - www.learn.microsoft.com/ru-ru/sql/sql-server/
4. **Базы данных : учеб, пособие для вузов** - Кузин А. В.
5. **Основы SQL : учеб, пособие для вузов** - Полякова Л. Н.

### 2. Запросы к базе данных. Виды запросов. Язык SQL. Запросы по образцу (QВЕ).

#### **Запрос**
Каждая СУБД должна предоставлять возможность чтения, добавления, изменения и удаления записей из БД со стороны пользователя СУБД (чаще всего пользователем СУБД выступают информационные системы), если, конечно, у него есть **соответствующие права**. Для достижения этой цели в СУБД предусмотрен **язык запросов**, представляющий набор основных правил, которым должны следовать все запросы к СУБД.

Вид запросов, главным образом, зависит от модели данных, которая используется в СУБД. Если модель данных поддерживает определенный порядок элементов ( например “модель инвертированных таблиц”, “иерархическая модель”), то все запросы к СУБД начинаются с операции позиционирования ( необходимо явно переместиться на определенный объект БД ). Если же модель данных состоит из объектов, не поддерживающих порядок, как, например, **“реляционная модель данных”**, в которой все таблицы представляют собой множество кортежей, то операция позиционирования не требуется и можно писать запросы в декларативном виде. 
#### **Язык SQL**
Обычно языки БД разделяются на два вида:

1. DDL (Data definition language) - язык определения схемы базы данных.
2. DML (Data manipulation language) - язык манипулирования данными.

Язык SQL объединяет в себе обе функции, т.е. язык SQL используется как для определения схемы БД, так и для написания запросов.
#### **Определения БД**
Основным элементом определения схемы БД в языке SQL является оператор CREATE TABLE, который создаёт новую таблицу. При создании новой таблицы можно указать имена столбцов, типы значений, которые будут храниться в этих столбцах ( целочисленный тип, тип с плавающей точкой, тип строки, тип даты и т.д.). Также для каждого столбца можно указать значение по умолчанию, обозначить соответствующий столбец как первичный ключ, или как внешний [1]. Общий вид операции создания новой таблицы представлен ниже:

    CREATE TABLE имяТаблицы (
    имяСтолбца1 тип1 [дополнительныеУсловия1],
    имяСтолбца2 тип2 [дополнительныеУсловия2],
    имяСтолбца3 тип3 [дополнительныеУсловия3],
    ...
    );

В качестве примера демонстрируется создания таблицы служащих, в которой содержится номер паспорта (целочисленное, первичный ключ), имя (строка) и номер отдела, в котором работает служащий (целочисленное, внешний ключ к столбцу **Номер** таблицы **Отделы.**

    CREATE TABLE Служащие (
    Номер_паспорта int PRIMARY KEY,
    Имя varchar(255),
    Номер_отдела int FOREIGN KEY REFERENCES Отделы(Номер)
    );

##### **Манипулирования данными**
##### **SELECT**
Основным элементом манипулирования данными языка SQL является оператор выборки, общая форма которого представлена ниже [2]:

    SELECT [DISTINCT] списокСтолбцов1
    FROM списокСсылокНаТаблицы
    [WHERE условноеВыражение1]
    [GROUP BY списокСтолбцов2]
    [HAVING условноеВыражение2]
    [ORDER BY списокСтолбцов3]

На данном изображение разделы, помещенные в квадратные скобки являются необязательными и их можно пропустить.

Выборка данных производиться из одной или нескольких таблиц, представленных в разделе **FROM.** 

    SELECT attribute
    FROM table;

Если таблиц больше одной, то, перед выполнением выборки, они объединяются в одну путём операции расширенного **Декартового умножения**. 

    SELECT attribute1, attribute2
    FROM table1, table2;

Также таблицы в разделе FROM могут быть полученные в результате применения другого оператора SELECT.

На следующем шаге происходит фильтрация на основе условия, определённого в разделе **WHERE**. При пропуске раздела WHERE фильтрации не происходит и все выбранные строки переходят дальше. Ниже показано использование WHERE в запросе, получающий имена всех служащих из таблицы “Служащие”, которые имеют зарплату более 40000 рублей.

    SELECT Имя
    FROM Служащие
    WHERE Зарплата > 40000;

Раздел **GROUP BY** позволяет группировать результаты по указанным атрибутам. При его использовании в разделе SELECT разрешается использовать только имена тех столбцов, по которым осуществляется группировка, а также агрегатные функции:

- COUNT(\*) - подсчитать число элементов внутри группы
- MIN(столбец) - минимальное значение столбца внутри группы
- MAX(столбец) - максимальное значение столбца внутри группы
- и другие

Раздел **HAVING** действует аналогично разделу WHERE, только условия применяются не к отдельным строкам, а к всей группе. Если раздел HAVING присутствует, а раздел GROUP BY нет, то вся таблица воспринимается как одна группа.

В качестве примера использования разделов GROUP BY и HAVING,  демонстрируется запрос, получающий список отделов фирмы , в которых работают не менее 10 служащих:

    SELECT Номер_отдела
    FROM Отделы JOIN Служащие ON Отделы.Номер_отдела = Служащие.Номер_отдела
    GROUP BY Номер_отдела
    HAVING count(*) >= 10;

Раздел **ORDER BY** позволяет указать порядок сортировки значений в результирующей таблице. Можно выполнять сортировку по нескольким столбцам с указанием порядка сортировки( от большего к меньшему / от меньшего к большему ).

#### **INSERT**

Операция вставки нового значения в таблицу осуществляется с помощью оператора **INSERT INTO**, для которого необходимо указать имя таблицы, список столбцов, в которые будет происходить вставка значений, а также сами значения вставки [3]. Общий вид операции вставки представлен ниже:

    INSERT INTO имяТаблицы (столбец1, столбец2, столбец2, ...)
    VALUES (значение1, значение2, значение3, ...);

В качестве примера приводится операция вставки нового служащего в таблицу Служащие:

    INSERT INTO Служащие (Номер_паспорта, Имя, Номер_отдела)
    VALUES (314159, “Иванов Иван Иванович”, 2718);

Для удаления данных из таблицы необходимо использовать оператор **DELETE FROM**, общий вид которого представлен ниже [4]:

    DELETE FROM имяТаблицы WHERE условие;

После выполнения данного запроса, из таблицы **“имяТаблицы”** будут удалены все записи, для которые было выполнено условие в разделе WHERE.

#### **QBE**

Теоретическую основу языка QBE составляет реляционное исчисление доменов. С помощью языка QBE можно создавать сложные запросы к базе данных, заполняя предлагаемую СУБД форму запроса. Данный способ создания запросов позволяет получить высокую наглядность и не требует указывать алгоритм выполнения операции. Каждая современная реляционная СУБД содержит свой вариант QBE.
В качестве использования QBE, демонстрируется запрос на получение имён всех служащих из таблицы Служащие, которые работают в отделе 8128:

В данном примере демонстрируется следующие:

    +----------------+-----+--------------+
    | Номер_паспорта | Имя | Номер_отдела |
    +----------------+-----+--------------+
    |                |P.   | 8128         |
    +----------------+-----+--------------+


1. Для того, чтобы включить столбец в результирующую таблицу, необходимо вписать в соответствующие поле строку “P.” ( первая буква слова Print)
2. Есть необходимо отфильтровать результаты по значению в определённом столбце, необходимо просто указать в соответствующие поле необходимое значение.
3. Есть столбец не используется в фильтрации и не включается в результирующую таблицу, то соответствующие ему поле просто пропускается.

#### **Источники**

1. SQL CREATE TABLE Statement: <https://www.w3schools.com/sql/sql_create_table.asp>
2. SQL SELECT Statement: <https://www.w3schools.com/sql/sql_select.asp>
3. SQL DELETE Statement: <https://www.w3schools.com/sql/sql_delete.asp>
4. SQL UPDATE Statement: <https://www.w3schools.com/sql/sql_update.asp>

### 4. Управление транзакциями. Модель транзакции. Свойства транзакции. Журнализация. Проблемы многопользовательских систем. Блокировки.

#### **Транзакция**

**Транзакция** - это последовательность операций над базой данных, рассматриваемых СУБД как единое целое.

Под управлением транзакциями понимается способность управлять различными операциями над данными, которые выполняются внутри реляционной СУБД. 

Управление транзакциями необходимо для поддержания логической целостности базы данных.

Пример транзакции (SQLite):

    BEGIN TRANSACTION;

    INSERT OR ROLLBACK INTO Orders (id_product, total)
    VALUES (2, 4800);

    UPDATE OR ROLLBACK Products
        SET quantity = quantity - 6
    WHERE id_product = 2;

    INSERT OR ROLLBACK INTO Invoices (id_order, id_product, num_order, sum_order, return, date)
    VALUES (1, 2, 6, 4800, 0, DATETIME('now'));

    COMMIT TRANSACTION;

#### **Модель транзакции**

**Модель транзакции** включает в себя следующие операторы:
    
1. **Оператор COMMIT**. Если все операции успешно выполнены, то транзакция также считается успешно выполненной и СУБД фиксирует (COMMIT) все изменения данных, произведенные этой транзакцией (то есть заносит изменения во внешнюю память).

2. **Оператор ROLLBACK**. Если же хотя бы одна операция транзакции заканчивается неудачей, то транзакция считается невыполненной и производится откат (ROLLBACK) — отмена всех изменений данных, произведенных в ходе выполнения транзакции, и возврат базы данных к состоянию до начала выполнения транзакции.

3. **Оператор SAVEPOINT**. Операция точки сохранения, которая предназначена для установки в транзакции особых точек, куда в дальнейшем может быть произведен откат (при этом отката всей транзакции не происходит).

Модель транзации можно видеть на следующей схеме:

<p align="center">
    <img src="pictures/4_1.jpg" style="width: 550px">
</p>

В этой схеме можно видеть следующие варианты работы транзакции:

1. Оператор COMMIT означает успешное завершение транзакции; его использование делает постоянными изменения, внесенные в базу данных в рамках текущей транзакции;

2. Оператор ROLLBACK прерывает транзакцию, отменяя изменения, сделанные в базе данных в рамках этой транзакции; новая транзакция начинается непосредственно после использования ROLLBACK;

3. Успешное завершение программы, в которой была инициирована текущая транзакция, означает успешное завершение транзакции (как будто был использован оператор COMMIT);

4. Ошибочное завершение программы прерывает транзакцию (как будто был использован оператор ROLLBACK).


#### **Свойства транзакции**

**Свойства транзакции** описываются аббревиатурой ACID (Atomicity, Consistency, Isolation, Durability):

1. **Свойство «Атомарность» (Atomicity)**. Атомарность гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем. Не допускаются промежуточные состояния.

2. **Свойство «Согласованность» (Consistency)**. Данное свойство гласит, что транзакция, достигающая своего нормального завершения и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных (то есть каждая успешная транзакция по определению фиксирует только допустимые результаты). Данное свойство «вытекает» из свойства атомарности.

3. **Свойство «Изолированность» (Isolation)**. Данное свойство означает, что транзакции параллельные транзакции не должны оказывать влияние на ее результаты.

4. **Свойство «Устойчивость» (Durability)**. Свойство означает, что если транзакция выполнена, и даже если в следующий момент произойдет сбой в системе, результат сохранится.

#### **Журнализация**

В случае аппаратных или программных сбоев может привести к повреждению данных в БД. Для восстановления информации в базе данных необходимо иметь некоторую дополнительную информацию. Таким образом, для поддержания надежности хранения данных требуется избыточность данных. Для таких целей существует **журнализация**.

**Журнал** хранит изменения, выполненные транзакциями, обеспечивает атомарность и устойчивость данных в случае сбоя системы.

**Журнал** содержит значения, которые данные имели до и после их изменения транзакцией. *Write-ahead log strategy* обязывает добавлять в журнал запись о предыдущих значениях до начала, а о конечных после завершения транзакции. В случае внезапной остановки системы БД читает лог в обратном порядке и отменяет изменения, сделанные транзакциями. Встретив прерванную транзакцию БД выполняет ее и вносит изменения о ней в журнал. Находясь в состоянии на момент сбоя, БД читает лог в прямом порядке и возвращает изменения, сделанные транзакциями.

#### **Проблемы многопользовательских СУБД**

Естественным следствием развития СУБД является проблема организации совместной работы нескольких пользователей с одной и той же совокупностью данных, или, проблемы многопользовательского доступа к данным.

Если в многопользовательской системе не реализованы механизмы совместной работы нескольких пользователей, то в СУБД это может привести к следующим проблемам:

1. **Проблема «последнего изменения»**. Возникает, когда несколько пользователей изменяют одну и ту же строку, основываясь на ее начальном значении; тогда часть данных будет потеряна, так как каждая последующая транзакция перезапишет изменения, сделанные предыдущей. Выход из этой ситуации заключается в последовательном внесении изменений;

2. **Проблема «грязного чтения»**. Возможна в том случае, если пользователь выполняет сложные операции обработки данных, требующие множественного изменения данных перед тем, как они обретут логически верное состояние. Если во время изменения данных другой пользователь будет считывать их, то может оказаться, что он получит логически неверную информацию. Для исключения подобных проблем необходимо производить считывание данных после окончания всех изменений;

3. **Проблема «неповторяемого чтения»**. Является следствием неоднократного считывания транзакцией одних и тех же данных. Во время выполнения первой транзакции другая может внести в данные изменения, поэтому при повторном чтении первая транзакция получит уже иной набор данных, что приводит к нарушению их целостности или логической несогласованности;

4. **Проблема «чтения фантомов»**. Появляется после того, как одна транзакция выбирает данные из таблицы, а другая вставляет или удаляет строки до завершения первой. Выбранные из таблицы значения будут некорректны.

Решением проблемы параллельной обработки БД заключается в том, что строки таблиц блокируются, а последующие транзакции, модифицирующие эти строки, отвергаются и переводятся в режим ожидания. Решается это с помощью блокировок.

#### **Блокировки**

**Блокировкой** называется временное ограничение на выполнение некоторых операций обработки данных. Блокировка может быть наложена как на отдельную строку таблицы, отдельную таблицу, так и на всю базу данных.

Управлением блокировками на сервере СУБД занимается менеджер блокировок, контролирующий их применение и разрешение конфликтов.

Транзакции и блокировки тесно связаны друг с другом. Транзакции накладывают блокировки на данные, чтобы обеспечить выполнение требований ACID. Без использования блокировок несколько транзакций могли бы изменять одни и те же данные.

Различают следующие типы блокировок:

1. По степени доступности данных: разделяемые и исключающие;
2. По множеству блокируемых данных: строчные, страничные, табличные;
3. По способу установки: автоматические (не явные) и явные;
4. По логике реализации: пессиместическая и оптимистическая.

Пример блокировки (MS SQL):

    LOCK TABLES users WRITE;
    INSERT INTO users (name) VALUES (‘Вася’);
    UNLOCK TABLES;

Работа с транзакциями есть и в моем проекте «Автоматизация извлечения информации о клиентах для базы 1С с применением машинного обучения». В моем случае, транзакция применяется когда пользователь захочет записать данные по всем найденным клиентам в БД. В этом случае, все временно созданные объекты пытаются записаться в транзакции. Если какой-то из объектов не удалось записать, тогда вся транзакция отменяется.

    НачатьТранзакцию();

    Попытка
        Для Каждого ТекущийОбработанныйОбъект Из ОбъектыОбработки Цикл
            ТекущийОбработанныйОбъект.ОбменДанным.Загрузка = Истина;
            ТекущийОбработанныйОбъект.Записать();
        КонецЦикла;

        ЗафиксироватьТранзакцию();
    Исключение
        ОтменитьТранзакцию();
    КонецПопытки;

Также в работе применяются и блокировки. Выполнить блокировку в 1С можно с помощью специального объекта встроенного языка 1С. Сделано это следующим образом:

	БлокировкаДанных = Новый БлокировкаДанных;
	
	ЭлементБлокировки = БлокировкаДанных.Добавить("Документ.ML_ФреймОбработкиДанных");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	ЭлементБлокировки.УстановитьЗначение("МодельМашинногоОбучения", ТекущаяМодельМашинногоОбучения);

	БлокировкаДанных.Заблокировать();

Блокировка в моей работе необходима для того, чтобы никто из пользоватей не мог редактировать дата сет по нужной модели машинного обучения, пока данная модель обучается или производится оценка ее точности.

Источники:

1. **Web SQL Database** - www.w3.org
2. **SQLite Documentation** - www.sqlite.org/docs.html
3. **MS SQL Documentation** - www.learn.microsoft.com/ru-ru/sql/sql-server/
4. **Базы данных : учеб, пособие для вузов** - Кузин А. В.
5. **Основы SQL : учеб, пособие для вузов** - Полякова Л. Н.

### 8. Система управления базами данных (СУБД). Функции и объекты СУБД.

Перед тем как дать определения СУБД, необходимо определиться с понятием базы данных.

#### **База данных**

**Базой данных** называется совокупность данных и метаданных. Метаданные представлять из себя правила о том, как должны соотноситься между собой разные элементы БД.

Если для текущего состояния БД все правила, описанные в метаданных, оказываются выполненными, то БД находится в состояние **целостности**. 

#### **Пример Базы данных**

Пусть наша база данных состоит из двух таблиц. Первая таблица хранит данные по каждому сотруднику. Заголовок данной таблице представлен ниже:

    +-----------+---------------+
    | СЛУ_НОМЕР | СЛУ_ОТД_НОМЕР |
    +-----------+---------------+

Вторая таблица хранит информацию по отделу, заголовок которой представлены ниже:

    +-----------+-------------+
    | ОТД_НОМЕР | ОТД_КОЛ_СЛУ |
    +-----------+-------------+

В каждой записи служащего столбец СЛУ\_ОТД\_НОМЕР - номер отдела из таблицы отделов, а в каждой записи отдела столбец ОТД\_КОЛ\_СЛУ - количество сотрудников в данном отделе. 

В данном примере мы имеем базу данных, в которой данными являются конкретные записи в таблицах служащие и отделы, а метаданные - правила, описанные ниже:

1. Для каждой записи из таблицы отделов ОТД\_КОЛ\_СЛУ должен равняться сумме всех служащих, у которых СЛУ\_ОТД\_НОМЕР равен ОТД\_НОМЕР текущей записи.
1. Для каждой записи из таблицы служащих должна существовать единственная запись таблицы отделов, у которой ОТД\_НОМЕР равен СЛУ\_ОТД\_НОМЕР текущей записи. 

#### **СУБД**

**СУБД** - это комплекс программных средств, посредством которых можно создавать БД и меня её состояние (добавлять, изменять и удалять записи)[1]. Также важной особенности СУБД являются механизмы поддержки целостности (проверка первичного и вторичного ключа, транзакции, восстановление после сбоев и т.д.). Примеры СУБД: SQLite, DB2, MS SQL.

#### **Функции СУБД**

#### **Управление данными во внешней памяти**

СУБД должна поддерживать определённую структуры во внешней памяти, которая будет хранить БД и набор служебной информации (индексы, журналы и т.д.).

Существует два подхода к реализации данной функции:

1. С активным использовать возможности файловой системы.
1. Использовать собственную систему именования объектов (применяется намного чаще).

Стоит также отметить, что не все СУБД хранят данные во внешней памяти, однако данных подход является самым популярным в наше время.

#### **правления буферами оперативной памяти**
Почти всегда СУБД поддерживает собственную систему буферизации данных и редко полагается на операционную систему. Так как СУБД известно намного больше о характере используемых данных, чем ОС, то СУБД может обеспечить более эффективную буферизация этих данных. 

#### **Управление транзакциями**
Транзакция позволяет объединить несколько операций над БД в один “атомарный” блок, который либо полностью выполняется, либо полностью отменяется. Управление транзакциями необходимо для обеспечения целостности БД, так как выполнения отдельных операций в транзакции может временно нарушать целостность данных [2].

#### **Журнализация **
СУБД должна иметь возможность восстанавливать целостность данных после сбоя. Основным способом достижения такой возможности является журнализация - ведение записей всех изменений над БД. Основным способом ведения журнала является протокол WAL (Write Ahead Log) - операция сначала записывается в журнал, а только потом выполняется.

#### **Объекты СУБД**
Объекты СУБД могут отличаться друг от друга в зависимости от того, какая модель данных используется.

#### **Модель данных**

**Модель данных** (МД) - это набор основным признаков и свойств, которыми должны обладать все БД, реализующие данную модель.
За историю развития баз данных было разработано множество различных МД. Ниже приведены некоторые из них:

#### **Модель инвертированных таблиц**
БД данной модели состоит из набора **упорядоченных** таблиц. Перед тем как изменить базу данных, необходимо выполнить операцию позиционирования - переместиться на необходимую строку в таблице.

#### **Иерархическая модель данных**
БД данной модели представляет собой набор переменных типа дерева. Каждый тип дерева состоит из корневого типа записи и набора типа поддеревьев, каждое из которых является некоторым типом дерева. Перед изменением БД также необходимо выполнить операцию позиционирования (переместиться от родителя к конкретному потомку, переместиться от потомка к родителю и т.д.).

#### **Реляционная модель данных**
Реляционная модель данных является самой распространённой на данный момент. БД реляционной модели данных состоит из набора **неупорядоченных** таблиц ( без порядка строк и столбцов), которую принято называть отношением [3]. 

Такой подход имеет массу приемуществ в сравнение с другими моделями данных:

1. Отсутствие порядка в таблицах приводит к отсутствию операции позиционирования. Это позволяет выполнять запросы в декларативном виде, что значительно упрощает использование СУБД.
2. Реляционный подход основан на использование фундаментальных математических конструкций - кортежей и отношений. Такое математическое определение упрощает процесс формальных рассуждений и помогает в решение задач оптимизации запросов.

### **Источники**

1. DBMS Introduction: <https://www.w3schools.in/dbms/intro>
2. DBMS Transaction: <https://www.w3schools.in/dbms/transaction>
3. Relational Data Model: <https://www.w3schools.in/dbms/relation-data-model>

### 9. Архитектура многопользовательских СУБД. Модель сервера баз данных. Сервер приложений. Трехуровневая модель.

#### **Архитектура многопользовательских СУБД.**

**Система управления базами данных (СУБД)** — совокупность
языковых и программных средств, предназначенных для создания, ведения
и совместного использования БД многими пользователями.

В зависимости от разделения функций между клиентом и сервером выделяются несколько типов архитектур систем БД, среди них:

#### **Модель сервера баз данных.**

Основу данной модели составляют следующие механизмы:
1. Механизм хранимых процедур - как средство программирования SQL-сервера;
2. Механизм триггеров - как механизм отслеживания текущего состояния информационного хранилища
3. Механизм ограничений на пользовательские типы данных, который иногда называется механизмом поддержки доменной структуры.

В этой модели бизнес-логика разделена между клиентом и сервером.
- На сервере бизнес-логика реализована в виде хранимых процедур — специальных программных модулей, которые хранятся в БД и управляются непосредственно СУБД.
- Клиентское приложение обращается к серверу с командой запуска хранимой процедуры, а сервер выполняет эту процедуру и регистрирует все изменения в БД, которые в ней предусмотрены. По итогу, сервер возвращает клиенту данные, релевантные его запросу, которые требуются клиенту либо для вывода на экран, либо для выполнения части бизнес-логики, которая расположена на клиенте.
    
Централизованный контроль в модели сервера баз данных выполняется с использованием механизма триггеров. Триггеры также являются частью БД. Механизм использования триггеров предполагает, что при срабатывании одного триггера могут возникнуть события, которые вызовут срабатывание других триггеров. Этот мощный инструмент требует тонкого и согласованного применения, чтобы не получился бесконечный цикл срабатывания триггеров.

В данной модели сервер является активным, потому что не только клиент, но и сам сервер, используя механизм триггеров, может быть инициатором обработки данных в БД. И хранимые процедуры, и триггеры хранятся в словаре БД, они могут быть использованы несколькими клиентами, что существенно уменьшает дублирование алгоритмов обработки данных в разных клиентских приложениях. Данную модель поддерживают большинство современных СУБД.

Модель сервера баз данных можно видеть на следующей схеме:

<p align="center">
    <img src="pictures/9_1.jpg">
</p>

#### **Сервер приложений. Трехуровневая модель.**

Эта модель является расширением двухуровневой модели. Данная архитектура предполагает наличие дополнительного сервера приложений, который проводит предварительную обработку запросов клиентов, формирует запросы к серверу БД и обрабатывает полученные результаты перед отправкой их клиенту.

В этой модели компоненты приложения делятся между тремя исполнителями:

1. Клиент обеспечивает логику представления, включая графический пользовательский интерфейс, локальные редакторы; клиент может запускать локальный код приложения клиента, который может содержать обращения к локальной БД, расположенной на компьютере-клиенте. Клиент исполняет коммуникационные функции front-end части приложения, которые обеспечивают доступ клиенту в локальную или глобальную сеть. Дополнительно реализация взаимодействия между клиентом и сервером может включать в себя управление распределенными транзакциями, что соответствует тем случаям, когда клиент также является клиентом менеджера распределенных транзакций.

2. Серверы приложений составляют новый промежуточный уровень архитектуры. Они спроектированы как исполнения общих незагружаемых функций для клиентов. Серверы приложений поддерживают функции клиентов как частей взаимодействующих рабочих групп, поддерживают сетевую доменную операционную среду, хранят и исполняют наиболее общие правила бизнес-логики, поддерживают каталоги с данными, обеспечивают обмен сообщениями и поддержку запросов, особенно в распределенных транзакциях.

3. Серверы баз данных в этой модели занимаются исключительно функциями СУБД: обеспечивают функции создания и ведения БД, поддерживают целостность реляционной БД, обеспечивают функции хранилищ данных (warehouse services). Кроме того, на них возлагаются функции создания резервных копий БД и восстановления БД после сбоев, управления выполнением транзакций и поддержки устаревших (унаследованных) приложений (legacy application).

Преимущества трехуровневой модели наиболее заметны в тех случаях, когда клиенты выполняют сложные аналитические расчеты над базой данных. 

Трехуровнивую модель можно видеть на следующей схеме:

<p align="center">
    <img src="pictures/9_2.jpg">
</p>

Трехуровневая модель применяется и в моем проекте «Автоматизация извлечения информации о клиентах для базы 1С с применением машинного обучения». Применяется она следующим образом: вся бизнес-логика реализована на сервере 1С, который может выполнять различные запросы на добавления, чтения, изменения или удаления данных на сервер БД. Результаты работы с БД сервер 1С отправляет пользователям, которые используют тонкий клиент 1С. Результаты работы отображаются в виде изменных форм приложения или различных сообщений, отчетов и прочего.

Схему работы можно видеть ниже:

<p align="center">
    <img src="pictures/9_3.jpg">
</p>

1. **Web SQL Database** - www.w3.org
2. **SQLite Documentation** - www.sqlite.org/docs.html
3. **MS SQL Documentation** - www.learn.microsoft.com/ru-ru/sql/sql-server/
4. **Базы данных : учеб, пособие для вузов** - Кузин А. В.
5. **Основы SQL : учеб, пособие для вузов** - Полякова Л. Н.


### 11. Основные алгоритмические структуры. Операторы условного и безусловного перехода. Циклические структуры, включая цикл foreach.

#### ***Основные алгоритмические структуры.***

**Алгоритмическая структура** - это структура, где каждая часть предназначена для выполнения определенного алгоритма преобразования информации 

Логическая структура любого алгоритма может быть представлена комбинацией трех базовых структур: *следование*, *ветвление*, *цикл*.

Самая простая из них - это **следование**. **Следование** — это часть алгоритма, в которой все команды исполняются одна за другой в порядке их записи. Алгоритм, в котором есть структура «следование» называется линейным. действие_1 действие_2 ... действие_n.

Схема:

<p align="center">
    <img src="pictures/11_1.svg" style="background: white; width: 150px">
</p>

Пример (Си):

    int a = 5;
    int b = 10;
    int c = a + b;

#### ***Операторы условного и безусловного перехода.***

Следующая группа алгоритмических структур - операторы условного и безусловного перехода.

**Ветвление** – это выбор действия в зависимости от выполнения какого-нибудь условия. Алгоритм, в котором есть структура «ветвление» называется разветвляющимся. 

Структура ветвление существует в четырех основных вариантах:

1. **если–то**; в этом случае выполнится действие (или группа действий), расположенное в строке то только при соблюдении условия. Если же условие не соблюдается, то исполнитель перейдет к выполнению действий, следующих за служебным словом все.

    Схема:

    <p align="center">
        <img src="pictures/11_2.svg" style="background: white; width: 150px">
    </p>

    Пример (Си):

        if (a > b) {
            return a;
        }

2. **если–то-иначе**; здесь представлена полная форма ветвления. В полной форме в зависимости от условия в строке если выполняется только одно из действий ( или группа действий), расположенных либо в строке то (условие соблюдено), либо в строке иначе (условие не соблюдено).

    Схема (Общая):

    <p align="center">
        <img src="pictures/11_3.svg" style="background: white; width: 400px">
    </p>

    Пример (Си):

        if (a > b) {
            return a;
        } else {
            return b;
        }

    Или пример с множественным ветвлением (Си):

        if (a > b) {
            return a;
        } else if (b > a) {
            return b;
        } else {
            return c;
        }

3. **Оператор множественного выбора**; Данный оператор сопоставляет значение заданного выражения с заранее предусмотренными вариантами. В большинстве языках реализован через оператор switch. Любую конструкцию выбора можно переписать в стандартное ветвление.

    Схема:

    <p align="center">
        <img src="pictures/11_4.svg" style="background: white; width: 500px">
    </p>

    Пример (Си):

        switch (keyCode) {
            case 1:
                // Действия для значения 1.
                break;
            case 2:
                // Действия для значения 2.
                // Обратите внимание, что нет оператора break;
                // Поэтому при выполнения case 2 выполнится case 3.
            case 3:
                // Действия для значения 3.
                break;
            default:
                // Действия, если не сопоставилось не один case.
                break;
        }

**Оператор безусловного перехода**. Оператор безусловного перехода goto означает «перейти к» и применяется в случаях, когда после выполнения некоторого оператора надо выполнить не следующий по порядку, а какой-либо другой, отмеченный меткой, оператор. Все языки программирования имели в свое время, а некоторые и до сих пор предлагают оператор goto, чье имя образовано слиянием двух английских слов "go to" (перейти к).

Применение оператора безусловного перехода считается «плохим тоном», по причине того, что данный оператор может привести к созданию нечитаемого «спагетти-кода» (очень запутанного кода).

Пример (Си):

    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++) {
            if (i == 3) {
                goto exit_jump;
            }
        }
        printf("%i\n", i);
    }

    exit_jump: printf("exit");

#### ***Циклические структуры, включая цикл foreach.***

И наконец, циклическая группа.

**Цикл** – это неоднократное повторение каких–либо действий. Алгоритм, в котором есть структура «цикл» называется циклическим. Обеспечивает многократное выполнение некоторой совокупности действий, которая называется телом цикла.

Основные разновидности циклов:

1. Цикл с предусловием; Цикл, который выполняется, пока истинно некоторое условие, указанное перед его началом. Это условие проверяется до выполнения тела цикла, поэтому тело может быть не выполнено ни разу (если условие с самого начала ложно). В большинстве процедурных языков программирования реализуется оператором while, отсюда его второе название — while-цикл.

    Схема:

    <p align="center">
        <img src="pictures/11_5.svg" style="background: white; width: 150px">
    </p>

    Пример (Си):

        int a = 0;

        while (a++ < 5) {
            printf("%i\n", a);
        }

2. Цикл с постусловием; Цикл, в котором условие проверяется после выполнения тела цикла. Отсюда следует, что тело всегда выполняется хотя бы один раз.

    Схема:

    <p align="center">
        <img src="pictures/11_6.svg" style="background: white; width: 150px">
    </p>


    Пример (Си):

        int a = 1;

        do {
            printf("%i\n", a);
        } while (a++ < 5);

3. Цикл со счетчиком; Цикл, в котором некоторая переменная изменяет своё значение от заданного начального значения до конечного значения с некоторым шагом, и для каждого значения этой переменной тело цикла выполняется один раз. В большинстве процедурных языков программирования реализуется оператором for, в котором указывается счётчик (так называемая «переменная цикла»), требуемое количество проходов (или граничное значение счётчика) и, возможно, шаг, с которым изменяется счётчик.

    Схема:

    <p align="center">
        <img src="pictures/11_7.svg" style="background: white; width: 250px">
    </p>

    Пример (Си):

        for (int i = 1; i <= 5; i++) {
            printf("%i", i);
        }

4. Цикл foreach; Цикл, задающий выполнение некоторой операции для объектов из заданного множества, без явного указания порядка перечисления этих объектов. Такие циклы называются совместными (а также циклами по коллекции, циклами просмотра) и представляют собой формальную запись инструкции вида: «Выполнить операцию X для всех элементов, входящих во множество M».

    Пример (Python):

        lst = [1, 2, 3, 4, 5]

        for lst_elem in lst:
            print(lst_elem)

Все приведенные алгоритмические структуры и используются в моем проекте «Автоматизация извлечения информации о клиентах для базы 1С с применением машинного обучения».

Пример ветвления из проекта (Встроенный язык 1С):

	Если ЭтоДокумент Тогда
		СтандартныеРеквизитыЗаполнены	= ЗначениеЗаполнено(ОбрабатываемыйОбъект.Дата);
		СтандартныйРеквизитОтказаЗаписи	= "Дата";
	Иначе
		СтандартныеРеквизитыЗаполнены	= ЗначениеЗаполнено(ОбрабатываемыйОбъект.Наименование);
		СтандартныйРеквизитОтказаЗаписи	= "Наименование";
	КонецЕсли;

Источники:

1. **WebAssembly Core Specification** - www.w3.org
2. **The GNU C Reference Manual** - www.gnu.org/software/gnu-c-manual
3. **Информатика и программирование. Основы информатики** - Н. И. Парфилова.
4. **Алгоритмы и структуры данных** - Гагарина Л. Г.

### 13. Классы и объекты в объектно-ориентированном программировании. Наследование и полиморфизм.

Основным понятием в объектно-ориентированном программирование является понятие объекта и класса.

#### **Объект**

Объект, в самом общем смысле, это сущность, которая объединяет в себе данные и код, который может манипулировать этими данными [1]. Достаточно часто объект обладает следующими признаками:

1. Как правило, объект является **абстракцией** некоторой реальной сущности той предметной области, в рамках которой разрабатывается программный продукт. 
2. Как правило, объект должен **поддерживать инкапсуляцию** - менять данные вне этого объекта можно только путём вызова определённого кода ( публичных методов, свойств и т.д.).

#### **Класс **

Класс - это **схема построения объекта**, в которой указываются данные (члены-данные) и код, который будет оперировать этими данными (члены-функции), а также модификаторы их доступа. Если объект получается по схеме такого класса, то его можно назвать **экземпляром** или **объектом класса**.
Стоит также отметить, что существуют другие подходы к определению классов и объектов. Так, в моём случае, определения класса даётся после определения объекта, но можно действовать наоборот: сначала определить понятие класса, а затем дать определение объекту как экземпляр класса.

#### **Модификаторы доступа**

ООП поддерживает 3 вида модификаторов доступа для членов класса:

1. **Публичный** - каждый публичный член класса доступен из вне этого класса для чтения / изменений (если это данные класса) или выполнения ( функции-члены).
2. **Приватные** - каждый приватный член класса не доступен за пределами этого класса.
3. **Защищённые** - защищённый член класса доступен всем дочерним классам и никому кроме дочерних классов.

#### **Члены-данные**

Данные класса можно разделить на два типа:

- Переменные экземпляра, которые могут отличаться у разных объектов.
- Статические переменные, которые являются общими для всех экземпляров данного класса.

#### **Члены-функции**

Функции члены бывают следующих типов:

- **Методы** - функции, которые можно вызвать у экземпляра класса и, **в общем случае**, изменить состояния этого класса (метод может и не менять состояния класса).
- **Конструкторы** - функции, которые вызываются один раз, после создания объекта класса.
- **Деструктор** - функции, которые вызываются один раз, перед уничтожением объекта класса.
- **Свойства** - пара функции для получения и записи значений, обращения к которым из вне класса ничем не отличается от обращения к открытым полям класса.

Помимо объектов и классов, методика программирования ООП активно использует механизмы **наследования** и **полиморфизма**.

#### **Наследование**

Механизм наследования позволяет **дополнить** схему уже существующего класса новыми данными и функциями, или **переопределить** уже имеющиеся функции, если, кончено, это позволяет сделать наследуемый класс (например: переопределить виртуальный метод основного класса)[2]. Когда класса B наследует класса A, то класс B называется **дочерним** по отношению к классу A, а класс A **родительским** по отношению к классу B. Основное достоинство механизма наследования неразрывно связан с полиморфизмом, который мы сейчас рассмотрим. (хотя наследования и само по себе является достаточно хорошим инструментом, позволяющим избавиться от дублирования кода).

#### **Полиморфизм**

Полиморфизм, по отношению к классам, позволяет использовать дочерний класс в тех участках кода, которые требуют использования родительского класса. Таким образом, благодаря этому механизму, между потомком и родительским классом формируются отношения вида: **подмножество основного множества**. 
Пример использования полиморфизма и наследования на ЯП C#:

    class Animal
    {
        public virtual string MakeNoise()
        {
            return string.Empty;
        }
    }

    class Dog : Animal
    {
        public override string MakeNoise()
        {
            return "woof woof";
        }
    }

    class Cat : Animal
    {
        public override string MakeNoise()
        {
            return "meow meow";
        }
    }

    class Program
    {
        static void Main()
        {
            Dog dog = new Dog();
            Cat cat = new Cat();

            ExampleMethod(dog);
            ExampleMethod(cat);
        }

        static void ExampleMethod(Animal animal)
        {
            string animalNoise = animal.MakeNoise();
            Console.WriteLine($"This animal make noise like: {animalNoise}");
        }
    }

Результат выполнения программы:

    This animal make noise like: woof woof
    This animal make noise like: meow meow 

Также в объектно-ориентированном подходе существует полиморфизм на основа **интерфейсов**, который позволяет использовать в одном и том же коде разные классы, если они “скрыты”(реализуют) определённый интерфейс, необходимы для текущей работы. 
Сами интерфейсы представляют собой перечисления определённого функционала (чаще всего перечисления сигнатур методов), который должны присутствовать с публичными модификаторами доступа в классе, реализующий данный интерфейс [3].
Пример использования интерфейсов и полиморфизма на ЯП C#:

    interface NoisyObject
    {
        string MakeNoise();
    }

    class Dog : NoisyObject
    {
        public string MakeNoise()
        {
            return "woof woof";
        }
    }

    class Cat : NoisyObject
    {
        public string MakeNoise()
        {
            return "meow meow";
        }
    }

    class Program
    {
        static void Main()
        {
            Dog dog = new Dog();
            Cat cat = new Cat();

            ExampleMethod(dog);
            ExampleMethod(cat);
        }

        static void ExampleMethod(NoisyObject noisyObject)
        {
            string noise = noisyObject.MakeNoise();
            Console.WriteLine($"This object make noise like: {noise}");
        }
    }

Результат выполнения программы:

    This object make noise like: woof woof
    This object make noise like: meow meow 

#### **Источники**

1. C# OOP: <https://www.w3schools.com/cs/cs_oop.php>
1. C# Inheritance: <https://www.w3schools.com/cs/cs_inheritance.php>
1. Interfaces - define behavior for multiple types: <https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/interfaces>

### 18. UMLдиаграммы: классов, вариантов использования, деятельности, последовательностей, состояний.

UML – унифицированный язык моделирования. UML - это система обозначений, которую можно применять для объектно-ориентированного анализа и проектирования.
Его можно использовать для визуализации, спецификации, конструирования и документирования программных систем.
Как и любой другой язык, UML имеет собственные правила оформления моделей и синтаксис.
С помощью графической нотации UML можно визуализировать систему, объединить все компоненты в единую структуру,
уточнять и улучшать модель в процессе работы. На общем уровне графическая нотация UML содержит 4 основных типа элементов:

    	а. Фигуры;
    	б. Линии;
    	в. Значки;
    	г. Надписи.

UML-нотация является де-факто отраслевым стандартом в области разработки программного обеспечения, ИТ-инфраструктуры и бизнес-систем.

    а. Класс (class) — категория вещей, которые имеют общие атрибуты и операции. Диаграмма классов - структурная диаграмма
    языка моделирования UML, демонстрирующая общую структуру иерархии классов системы. Диаграмма классов являет собой
    набор статических, декларативных элементов модели. Она дает нам наиболее полное и развернутое представление о связях
    в программном коде, функциональности и информации об отдельных классах.

![image](https://github.com/IlyaSukharev01/magisters-novsu/assets/60602324/2cd1bf1a-5c2c-43d4-8dd8-42ff0a642655)
    	
    б. Диаграммы вариантов использования(use case) описывают взаимоотношения и зависимости между группами вариантов использования
       и действующих лиц, участвующими в процессе.
       
       Диаграмма использует 2 основных элемента: 

	1) Actor (участник) — множество логически связанных ролей, исполняемых при взаимодействии с прецедентами или
 	сущностями (система, подсистема или класс). Участником может быть человек, роль человека в системе или другая
  	система, подсистема или класс, которые представляют нечто вне сущности. 

	2) Use case (прецедент) — описание отдельного аспекта поведения системы с точки зрения пользователя.
 	Прецедент не показывает, "как" достигается некоторый результат, а только "что" именно выполняется.

  ![image](https://evergreens.com.ua/assets/images/articles/uml-diagrams/use_case_diagram.png)
  
       
    в. Диаграмма деятельности позволяет более детально визуализировать конкретный случай использования. Это поведенческая диаграмма,
       которая иллюстрирует поток деятельности через систему. Диаграммы активности UML также могут быть использованы
       для отображения потока событий в бизнес-процессе.
       Диаграмма активностей описывает динамические аспекты поведения системы в виде блок-схемы,
       которая отражает бизнес-процессы, логику процедур и потоки работ — переходы от одной деятельности к другой. 
       По сути, мы рисуем алгоритм действий (логику поведения) системы или взаимодействия нескольких систем.

![image](https://github.com/IlyaSukharev01/magisters-novsu/assets/60602324/17edd229-bd53-47bd-95fa-8edcf07cdbb5)

       
    г. Диаграммы последовательности - диаграмма, на которой для некоторого набора объектов на единой временной оси показан
	жизненный цикл объекта (создание-деятельность-уничтожение некой сущности) и взаимодействие акторов 
	(действующих лиц) информационной системы в рамках прецедента.
	Диаграмма используется для уточнения диаграмм прецедентов — описывает поведенческие аспекты системы.
 	Диаграмма последовательности отражает взаимодействие объектов в динамике, во времени.
  	При этом информация принимает вид сообщений, а взаимодействие объектов подразумевает обмен этими сообщениями
   	в рамках сценария.

![image](https://github.com/IlyaSukharev01/magisters-novsu/assets/60602324/dde2a491-c692-4a96-be06-e2511163be59)

 
    д. Диаграмма состояний описывает процесс изменения состояний только одного класса, а точнее – одного экземпляра
       определенного класса, т. е. моделирует все возможные изменения в состоянии конкретного объекта.
       Диаграмма позволяет визуально представить различные состояния объекта или системы и показать, 
       как они изменяются в ответ на события или внешние условия. Переходы обозначают изменение состояния и указывают,
       при каких условиях происходит переход между состояниями. События являются внешними сигналами или действиями, 
       которые вызывают переходы между состояниями.

![image](https://github.com/IlyaSukharev01/magisters-novsu/assets/60602324/cd973de5-970b-4ec8-b276-6aeb8e4025bd)


1. **Uml примеры** - https://codemanship.co.uk/parlezuml/
2. **Самоучитель UML 2.** Александр Леоненков
3. **Проектирование на UML.** Сборник задач. Валентин Полежаев, Андрей Андрианов, Антон Хританков
4. **UML 2.0. Объектно-ориентированное моделирование и разработка.** Джеймс Рамбо, М. Блаха



### 19. Рекурсивные функции и данные. Пример рекурсивного алгоритма. Достоинства рекурсии и недостатки.
	
Функция — в программировании — это поименованная часть программы, которая может вызываться из других
частей программы столько раз, сколько необходимо. Функция, в отличие от процедуры, обязательно возвращает значение.

Рекурсия — это функция, которая вызывает саму себя. Представим, что есть функция А, которая выполняет определённое действие,
— например, перемножает два значения. Внутри этой функции А в качестве одного из значений для умножения возьмём ту
же самую функцию А. Получается, что функция умножает число на саму себя и внутри ещё раз умножает число на саму себя
и так далее, до бесконечности или выполнения определённого условия.

Рекурсия функции нужна, когда требуется выполнить последовательность из одинаковых действий.
Прописывать их все слишком долго, а иногда невозможно, потому что неизвестно, сколько действий понадобится.
Например, надо создать функцию, которая выводит на экран числа от N до 1. Но конечное N неизвестно,
и нужно передавать каждый раз разное. Тут и поможет рекурсия — она каждый раз будет вызывать сама себя,
уменьшая заданное N на один, пока не дойдёт до единицы.

Рекурсия немного похожа на цикл, который тоже позволяет несколько раз повторить одно и то же действие.
Но внутри цикла функция не вызывается, только прописываются различные условия. Любую рекурсивную функцию
можно описать в виде цикла, так что теоретически рекурсии можно не использовать в коде вообще.
Однако у них есть преимущества перед циклами.


Недостатки.

      а. Скорость работы рекурсивного кода. Некоторые компиляторы могут преобразовывать хвостовую
         рекурсию в цикл, но, в целом, итеративные реализации работают быстрее практически во
         всех случаях, когда использование циклов НЕ усложняет алгоритм.
      б. Требования к размеру стека, но это решается настройками компиляции или выбором языка,
         который не ограничивает размер стека
      в. Если забыть прописать условие выхода, рекурсия будет выполняться бесконечно — программу придётся завершать принудительно.

Достоинства.

      а. Эффективность применения. Некоторые алгоритмы выглядят проще и понятнее с использованием рекурсии.
      б. Рекурсии легче реализовывать, чем итерации.
      в. Иногда код рекурсии можно упаковать в несколько строк, в то время как такой же цикл займёт
      	 десятки строк кода. В этом случае рекурсия будет выполняться быстрее аналогичного цикла.

Суть рекурсии такова, что она может вызывать сама себя вечно, никогда не заканчиваясь.
Это называется бесконечной рекурсией, выйти из которой можно только принудительным закрытием программы.

Принцип «Разделяй и властвуй» — самое популярное и частое применение для рекурсии. Декомпозиция, то есть разбиение любой
задачи на более мелкие части, — основа, на которой строится принцип рекурсии:

	1.Разделять. Решать проблему напрямую, если она небольшая. В противном случае разделить
 	задачу на меньшие подмножества той же проблемы.

	2.Властвовать. Решать меньшие задачи рекурсивно. Если подзадача достаточно мала, 
 	рекурсия не нужна и можно решить её напрямую.

	3.Комбинировать. Взять готовое решение для маленькой подзадачи и объединить с решением исходной проблемы.

	Как только большая задача будет разбита на множество мелких частей, можно использовать параллельное
 	программирование для их одновременного выполнения, ускоряя весь процесс решения.
  	Такой подход является самым быстрым и простым способом увеличить скорость алгоритма и всей программы.

Пример:

      Вычисление факториала:

      def factorial(x):
          if (x == 0):
              return 1
          return x * factorial(x - 1)

1. **Книга «Рекурсивная книга о рекурсии»** - Эл Свейгарт
2. **Искусство программирования.** Основные алгоритмы. - Дональд Кнут
3. **Функции в Python** - https://www.w3schools.com/python/python_functions.asp


    



